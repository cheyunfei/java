<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_231) on Tue Jul 21 17:30:20 GMT+08:00 2020 -->
<title>C - 索引</title>
<meta name="date" content="2020-07-21">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="C - \u7D22\u5F15";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../overview-summary.html">概览</a></li>
<li>程序包</li>
<li>类</li>
<li>使用</li>
<li><a href="../overview-tree.html">树</a></li>
<li><a href="../deprecated-list.html">已过时</a></li>
<li class="navBarCell1Rev">索引</li>
<li><a href="../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="index-2.html">上一个字母</a></li>
<li><a href="index-4.html">下一个字母</a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?index-files/index-3.html" target="_top">框架</a></li>
<li><a href="index-3.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="contentContainer"><a href="index-1.html">A</a>&nbsp;<a href="index-2.html">B</a>&nbsp;<a href="index-3.html">C</a>&nbsp;<a href="index-4.html">D</a>&nbsp;<a href="index-5.html">E</a>&nbsp;<a href="index-6.html">F</a>&nbsp;<a href="index-7.html">G</a>&nbsp;<a href="index-8.html">I</a>&nbsp;<a href="index-9.html">J</a>&nbsp;<a href="index-10.html">L</a>&nbsp;<a href="index-11.html">M</a>&nbsp;<a href="index-12.html">N</a>&nbsp;<a href="index-13.html">O</a>&nbsp;<a href="index-14.html">P</a>&nbsp;<a href="index-15.html">R</a>&nbsp;<a href="index-16.html">S</a>&nbsp;<a href="index-17.html">T</a>&nbsp;<a href="index-18.html">U</a>&nbsp;<a href="index-19.html">V</a>&nbsp;<a href="index-20.html">W</a>&nbsp;<a href="index-21.html">Z</a>&nbsp;<a name="I:C">
<!--   -->
</a>
<h2 class="title">C</h2>
<dl>
<dt><a href="../Calculate/package-summary.html">Calculate</a> - 程序包 Calculate</dt>
<dd>&nbsp;</dd>
<dt><a href="../DataClass/CharacterClass.html" title="DataClass中的类"><span class="typeNameLink">CharacterClass</span></a> - <a href="../DataClass/package-summary.html">DataClass</a>中的类</dt>
<dd>
<div class="block">（1）Character 类的构造方法： Character mychar=new Character( char c )<br><br>
 （2）Character 类常用方法：Character mychar=new Character( char c )<br>
 （2.1）char c=mychar.charValue()<br>
 （2.2）int i=mychar1.compareTo( Character other )，【比较两个 Character 对象是否相等，值为 mychar-other 的差值】<br>
 （2.3）boolean b=obj.equals( Object obj2 )，【这里调用此函数的对象必须是包装类的对象，而不能是基本数据类型，
                                  比如不能是 char 或 int ，可以是 Character 或 Integer】<br>
 （2.4）Character c=Character.toLowerCase( Character c / char c )，【注意 tolowerCase 不能由 char 直接调用】<br>
 （2.5）Character c=Character.toUpperCase( Character c / char c )，【注意 toUpperCase 不能由 char 直接调用】<br>
 （2.6）String s=mychar.toString()，【注意 toString 不能由 char 直接调用，char 只是类Character 中封装的基本类型属性】<br>
 （2.7）boolean b=Character.isUpperCase( Character c / char c )<br>
 （2.8）boolean b=Character.isLowerCase( Character c / char c )<br><br>
 （3）Character类的常量：byte b=Character.CONNECTOR_PUNCTUATION【返回 byte 类型值，表示Unicode规范中
                                   的常规类别“Pc”,值为23】<br>
                                   byte b=Character.UNASSIGNED【返回 byte 类型值，表示Unicode规范中
                                   的常规类别“Cn”,值为0】<br>
                                   byte b=Character.UNASSIGNED【返回 byte 类型值，表示Unicode规范中
                                   的常规类别“Cn”,值为3】<br><br>
（4）字符数据 char 类型在内存中占两个字节<br><br>
（5）String 类：通过观察源码可以发现，String类其实维护的是一个字符数组，即字符串String中的每个字符都占两个字节<br><br>
（6）Unicode：通常用两个字节表示一个字符，原有的英文编码也从单字节变成双字节【也就是把高字节用0填充，低字节保持原本的ASCII码
    】。</div>
</dd>
<dt><span class="memberNameLink"><a href="../DataClass/CharacterClass.html#CharacterClass--">CharacterClass()</a></span> - 类 的构造器DataClass.<a href="../DataClass/CharacterClass.html" title="DataClass中的类">CharacterClass</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../swing/CheckBoxTest.html" title="swing中的类"><span class="typeNameLink">CheckBoxTest</span></a> - <a href="../swing/package-summary.html">swing</a>中的类</dt>
<dd>
<div class="block">（1）复选框：与单选按钮唯一的不同是，复选框可以进行多选设置
 （2）复选框：public JCheckBox（Icon icon/String text，boolean checked），icon【只能看见图片，没有方框
                  ，但是点击仍可以改变复选框状态，并触发监听器，至于是不是图片挡住了方框有待实验解决】，text【复选
                  框旁边的说明文字】，checked【复选框的初始状态，true选中/false未选中】，以上两个参数可以视情况添
                  加或彻底不加<br>
          （2.1）JCkeckBox.isSelected()【返回boolean类型的值，true此时复选框状态为选中/false此
               时复选框状态为未选中】<br><br>
 （3）复选框添加触发器：点击一次复选框，状态改变一次，触发一次动作触发器<br><br></div>
</dd>
<dt><span class="memberNameLink"><a href="../swing/CheckBoxTest.html#CheckBoxTest--">CheckBoxTest()</a></span> - 类 的构造器swing.<a href="../swing/CheckBoxTest.html" title="swing中的类">CheckBoxTest</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../class_high_character/package-summary.html">class_high_character</a> - 程序包 class_high_character</dt>
<dd>&nbsp;</dd>
<dt><a href="../interface_hire_varycondition/ClassConverUp.html" title="interface_hire_varycondition中的类"><span class="typeNameLink">ClassConverUp</span></a> - <a href="../interface_hire_varycondition/package-summary.html">interface_hire_varycondition</a>中的类</dt>
<dd>
<div class="block">（1）父类是较抽象的类，子类是较具体的类
（2）向上转型：子类对象可以看作是一个父类对象，Father obj=new Son()，当此对象作为父类方法中参数时，
                          可以实现多个不同的子类继承同一个父类方法，而父类方法中按子类类型分别处理，从而避免每个子类
                          都重写此方法造成的代码复杂，以实现多态【如 public void Method( Father obj )，调
                          用 Method( new Son )，然后在方法 Method 中使用 obj.getClass().getName().equals("包名.子类名") 来
                          判断是哪个子类，然后按不同子类使用不同的处理过程】<br>
        （2.1）向上转型后注意事项：向上转型后不能调用上级类不存在，下级类存在的方法；虽然此时是父类对象，调用的
                         却是子类中覆盖父类后的新方法

（3）向下转型：这样容易出现问题，如果父类对象不是子类对象的实例【Father fatherObj=new Father()】，向下转
                            型出现 ClassCastException 错误，只有父类对象是子类对象的实例【Father fatherObj=new Son()】，
                            然后显式的使用强制转换方式，即 Son obj=(Son)fatherObj，向下转型才能成功，因此为了判断这两种情况
                            引入 instanceof
   
（4）instanceof：“obj instanceof Class”，返回 boolean 值<br>
  （4.1）只能用于判断父类和子类之间的关系，不能判断无关类间的关系，【Father、Son、Any三个类，“public Son extends Father”
                             “fatherObj instanceof Son”或“sonObj instanceof Father”语句合法，但是“fatherObj instanceof Any”语句本身就
                             是错误的】<br>
  （4.2）在向下转型之前，用于判断父类对象是否是子类对象的实例【Father obj=new Son()，此
                             时“obj instanceof Son”返回 true，“obj instanceof Father”返回true】，虽然 Son 是 Father 的子类【 Father obj=new Father()，
                             此时“obj instanceof Son”返回 false，“obj instanceof Father”返回true】<br>
   （4.3）可以使用 instanceof 判断某类是否实现了某个接口，也可以判断一个实例对象是否属于一个类，只要是向下(向上)转型相关联
              的对象和类“obj instanceof Class”返回值都是 true 【向上转型后父类对象是子类对象的实例，向下转型后子类
              对象是父类对象的实例】<br></div>
</dd>
<dt><span class="memberNameLink"><a href="../interface_hire_varycondition/ClassConverUp.html#ClassConverUp--">ClassConverUp()</a></span> - 类 的构造器interface_hire_varycondition.<a href="../interface_hire_varycondition/ClassConverUp.html" title="interface_hire_varycondition中的类">ClassConverUp</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../Reflect_Annotation/ClassTest.html" title="Reflect_Annotation中的类"><span class="typeNameLink">ClassTest</span></a> - <a href="../Reflect_Annotation/package-summary.html">Reflect_Annotation</a>中的类</dt>
<dd>&nbsp;</dd>
<dt><span class="memberNameLink"><a href="../Reflect_Annotation/ClassTest.html#ClassTest--">ClassTest()</a></span> - 类 的构造器Reflect_Annotation.<a href="../Reflect_Annotation/ClassTest.html" title="Reflect_Annotation中的类">ClassTest</a></dt>
<dd>&nbsp;</dd>
<dt><span class="memberNameLink"><a href="../Reflect_Annotation/ClassTest.html#ClassTest-java.lang.String-">ClassTest(String)</a></span> - 类 的构造器Reflect_Annotation.<a href="../Reflect_Annotation/ClassTest.html" title="Reflect_Annotation中的类">ClassTest</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../Reflect_Annotation/ClassTest.inner2.html" title="Reflect_Annotation中的类"><span class="typeNameLink">ClassTest.inner2</span></a> - <a href="../Reflect_Annotation/package-summary.html">Reflect_Annotation</a>中的类</dt>
<dd>&nbsp;</dd>
<dt><a href="../collection/package-summary.html">collection</a> - 程序包 collection</dt>
<dd>&nbsp;</dd>
<dt><a href="../collection/CollectionTest.html" title="collection中的类"><span class="typeNameLink">CollectionTest</span></a> - <a href="../collection/package-summary.html">collection</a>中的类</dt>
<dd>
<div class="block">一、集合类：由包 java.util 包导入，集合类与数组不同的是，数组长度固定，集合长度可变；数组用来存放
              基本类型的数据，集合用来存放对象的引用，即为对象引用的集合。</div>
</dd>
<dt><span class="memberNameLink"><a href="../collection/CollectionTest.html#CollectionTest--">CollectionTest()</a></span> - 类 的构造器collection.<a href="../collection/CollectionTest.html" title="collection中的类">CollectionTest</a></dt>
<dd>&nbsp;</dd>
<dt><span class="memberNameLink"><a href="../collection/UpdateStu.html#compareTo-java.lang.Object-">compareTo(Object)</a></span> - 类 中的方法collection.<a href="../collection/UpdateStu.html" title="collection中的类">UpdateStu</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../ProgramLogic/Compound.html" title="ProgramLogic中的类"><span class="typeNameLink">Compound</span></a> - <a href="../ProgramLogic/package-summary.html">ProgramLogic</a>中的类</dt>
<dd>
<div class="block">{ } 括住的的为一个语句块，语句块可以嵌套，同时注意语句块中变量的作用域</div>
</dd>
<dt><span class="memberNameLink"><a href="../ProgramLogic/Compound.html#Compound--">Compound()</a></span> - 类 的构造器ProgramLogic.<a href="../ProgramLogic/Compound.html" title="ProgramLogic中的类">Compound</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../Reflect_Annotation/ConstructorAndModifierTest.html" title="Reflect_Annotation中的类"><span class="typeNameLink">ConstructorAndModifierTest</span></a> - <a href="../Reflect_Annotation/package-summary.html">Reflect_Annotation</a>中的类</dt>
<dd>&nbsp;</dd>
<dt><span class="memberNameLink"><a href="../Reflect_Annotation/ConstructorAndModifierTest.html#ConstructorAndModifierTest--">ConstructorAndModifierTest()</a></span> - 类 的构造器Reflect_Annotation.<a href="../Reflect_Annotation/ConstructorAndModifierTest.html" title="Reflect_Annotation中的类">ConstructorAndModifierTest</a></dt>
<dd>&nbsp;</dd>
<dt><span class="memberNameLink"><a href="../Reflect_Annotation/ConstructorAndModifierTest.html#ConstructorAndModifierTest-java.lang.String-int-">ConstructorAndModifierTest(String, int)</a></span> - 类 的构造器Reflect_Annotation.<a href="../Reflect_Annotation/ConstructorAndModifierTest.html" title="Reflect_Annotation中的类">ConstructorAndModifierTest</a></dt>
<dd>&nbsp;</dd>
<dt><span class="memberNameLink"><a href="../swing/FrameExample.html#CreateJFrame-java.lang.String-">CreateJFrame(String)</a></span> - 类 中的方法swing.<a href="../swing/FrameExample.html" title="swing中的类">FrameExample</a></dt>
<dd>&nbsp;</dd>
<dt><a href="../Abstract/CreateObject.html" title="Abstract中的类"><span class="typeNameLink">CreateObject</span></a> - <a href="../Abstract/package-summary.html">Abstract</a>中的类</dt>
<dd>
<div class="block">（1）对象的创建通过 new 这个关键字 ：语句“new 对象名”，此时 new 操作符创建对象，调用构造方法<br><br>
 （2）注意同一个类中不同对象对成员变量的引用是独立的，对静态变量的引用是重叠的<br><br>
 （3）对象的操作标识符其实只是一个对象的引用，其就是一个对象的内存地址<br><br>
 （4）对象的比较：“obj1.equals(obj2)”，【比较的是对象内容是否相等】；“obj1==obj2”,【比较的
                       是对象的引用地址是否相同】<br><br>
 （5）对象的销毁：可以被垃圾回收机制自动销毁的对象【由 new 创建，并且超出作用范围或“obj=null”的
                       对象可以被销毁】；对于非 new 创建的对象，通过在类中定义 finalize() 方法【Object类的方法】；
                       垃圾回收机制和 finalize 发生的时间不定，即Java虚拟机内存消耗殆尽之前不会执行垃圾回收
                       ，通过“System.gc()”强制启动垃圾回收器<br><br></div>
</dd>
<dt><span class="memberNameLink"><a href="../Abstract/CreateObject.html#CreateObject--">CreateObject()</a></span> - 类 的构造器Abstract.<a href="../Abstract/CreateObject.html" title="Abstract中的类">CreateObject</a></dt>
<dd>&nbsp;</dd>
</dl>
<a href="index-1.html">A</a>&nbsp;<a href="index-2.html">B</a>&nbsp;<a href="index-3.html">C</a>&nbsp;<a href="index-4.html">D</a>&nbsp;<a href="index-5.html">E</a>&nbsp;<a href="index-6.html">F</a>&nbsp;<a href="index-7.html">G</a>&nbsp;<a href="index-8.html">I</a>&nbsp;<a href="index-9.html">J</a>&nbsp;<a href="index-10.html">L</a>&nbsp;<a href="index-11.html">M</a>&nbsp;<a href="index-12.html">N</a>&nbsp;<a href="index-13.html">O</a>&nbsp;<a href="index-14.html">P</a>&nbsp;<a href="index-15.html">R</a>&nbsp;<a href="index-16.html">S</a>&nbsp;<a href="index-17.html">T</a>&nbsp;<a href="index-18.html">U</a>&nbsp;<a href="index-19.html">V</a>&nbsp;<a href="index-20.html">W</a>&nbsp;<a href="index-21.html">Z</a>&nbsp;</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../overview-summary.html">概览</a></li>
<li>程序包</li>
<li>类</li>
<li>使用</li>
<li><a href="../overview-tree.html">树</a></li>
<li><a href="../deprecated-list.html">已过时</a></li>
<li class="navBarCell1Rev">索引</li>
<li><a href="../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="index-2.html">上一个字母</a></li>
<li><a href="index-4.html">下一个字母</a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?index-files/index-3.html" target="_top">框架</a></li>
<li><a href="index-3.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
